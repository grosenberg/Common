package net.certiv.common.util;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Properties;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.certiv.common.log.Log;

public class Version {

	// pom xml
	private static final Pattern VERSION = Pattern.compile("<version>(.*?)</version>");

	/**
	 * Returns the package version as generated by Maven.
	 *
	 * <pre>{@code
	 * <plugin>
	 *   <groupId>org.apache.maven.plugins</groupId>
	 *   <artifactId>maven-jar-plugin</artifactId>
	 *   <version>3.2.0</version>
	 *   <configuration>
	 *     <archive>
	 *       <manifest>
	 *         <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
	 *         <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
	 *       </manifest>
	 *     </archive>
	 *   </configuration>
	 * </plugin>
	 * }</pre>
	 *
	 * @param cls any class within a jar prepared by Maven with version information
	 * @return the specification version of the jar
	 */
	public static String pkgVersion(Class<?> cls) {
		Package pkg = cls.getPackage();
		String ver = pkg.getImplementationVersion();
		if (ver != null) return ver;
		ver = pkg.getSpecificationVersion();
		if (ver != null) return ver;
		return Strings.UNKNOWN;
	}

	/**
	 * Returns the value of the {@code version} key contained within a properties file of
	 * the given name located as a resource of the given class.
	 *
	 * @param cls      class used to locate the properties file
	 * @param filename name of the properties file
	 * @return property value for the {@code version} key
	 */
	public static String propertiesVersion(Class<?> cls, String filename) {
		ClassLoader cl = cls.getClassLoader();
		try (InputStream in = cl.getResourceAsStream(filename)) {
			Properties prop = new Properties();
			prop.load(in);
			return (String) prop.get("version");

		} catch (Exception e) {
			Log.error("Failed reading version from '%s': %s", filename, e.getMessage());
			return Strings.UNKNOWN;
		}
	}

	/**
	 * Returns the manifest "version" string of the manifest file.
	 * <p>
	 * If the reference class is not within a jar file, an attempt is made to read the
	 * "version" string from the {@code pom.xml} located in the Maven output directory
	 * root.
	 *
	 * @param cls a reference class file
	 * @return the verision
	 */
	public static String manifestVersion(Class<?> cls) {
		try {
			URI location = cls.getProtectionDomain().getCodeSource().getLocation().toURI();

			// handle jar-in-jar
			if (location.getScheme().equalsIgnoreCase("rsrc")) {
				try (InputStream is = cls.getResourceAsStream("/META-INF/MANIFEST.MF")) {
					if (is == null) Log.error("Failed to open Manifest stream: %s", ClassUtil.dump(cls));
					Manifest mf = new Manifest(is);
					return manifestVersion(mf);
				}
			}

			File file;
			try {
				file = new File(location);
			} catch (Exception e) {
				Log.debug("Manifest Location %s", location);
				throw e;
			}

			if (file.isFile()) {
				String ext = FsUtil.getExt(file.toPath());
				if (ext.equalsIgnoreCase("jar")) {
					try (JarFile jar = new JarFile(file)) {
						Manifest mf = jar.getManifest();
						return manifestVersion(mf);
					}
				}
				return Strings.UNKNOWN;

			} else if (file.isDirectory()) {
				Path dir = file.toPath();
				if (dir.endsWith("bin")) {
					dir = dir.getParent();
				} else if (dir.endsWith("target/classes")) {
					dir = dir.getParent().getParent();
				}
				File pom = dir.resolve("pom.xml").toFile();
				if (pom.isFile()) {
					String xml = FsUtil.readToString(pom);
					Matcher m = VERSION.matcher(xml);
					if (m.find()) {
						return m.group(1);
					}
				}
			}

		} catch (Exception e) {
			Log.error("Failed reading manifest version: %s", e.getMessage());
		}
		return Strings.UNKNOWN;
	}

	private static String manifestVersion(Manifest mf) throws IOException {
		Attributes attributes = mf.getMainAttributes();
		String ver = attributes.getValue("Implementation-Version");
		if (ver == null) {
			ver = attributes.getValue("Bundle-Version");
		}
		if (ver == null) {
			ver = Strings.UNKNOWN;
		}
		return ver;
	}

	/**
	 * Returns the given instant as a {@code LocalDateTime} in the system default time
	 * zone.
	 *
	 * @param instant the intant to convert
	 * @return a local date/time
	 */
	public static LocalDateTime toDateTime(Instant instant) {
		return LocalDateTime.ofInstant(instant, ZoneId.systemDefault());
	}

	public static Instant created(File file) throws IOException {
		BasicFileAttributes attr = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
		return attr.creationTime().toInstant();
	}

	public static Instant lastModified(File file) throws IOException {
		BasicFileAttributes attr = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
		return attr.lastModifiedTime().toInstant();
	}

	public static String creationDate(File file) {
		try {
			BasicFileAttributes attr = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
			FileTime date = attr.creationTime();
			SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			return df.format(date.toMillis());

		} catch (IOException e) {
			Log.error("Failed reading file creation date: %s", e.getMessage());
			return Strings.UNKNOWN;
		}
	}

	public static String modificationDate(File file) {
		try {
			BasicFileAttributes attr = Files.readAttributes(file.toPath(), BasicFileAttributes.class);
			FileTime date = attr.lastModifiedTime();
			SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			return df.format(date.toMillis());

		} catch (IOException e) {
			Log.error("Failed reading file last modification date: %s", e.getMessage());
			return Strings.UNKNOWN;
		}
	}
}
